学习笔记

#### 操作码
根据指令的性质，主要分为四个大类：
1. 栈操作指令，包括与局部变量交互的指令
2. 程序流程控制指令
3. 对象操作指令，包括方法调用指令
4. 算术运算以及类型转换指令

#### 方法调用的指令
1. invokestatic，顾名思义，这个指令用于调用某个类的静态方法，这是方法调用指令中最
快的一个。
2. invokespecial, 用来调用构造函数，但也可以用于调用同一个类中的 private 方法, 以及
可见的超类方法。
3. invokevirtual，如果是具体类型的目标对象，invokevirtual 用于调用公共，受保护和
package 级的私有方法。
4. invokeinterface，当通过接口引用来调用方法时，将会编译为 invokeinterface 指令。
5. invokedynamic，JDK7 新增加的指令，是实现“动态类型语言”（Dynamically Typed
Language）支持而进行的升级改进，同时也是 JDK8 以后支持 lambda 表达式的实现基
础。

#### 类的初始化
1. 当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new
一个类的时候要初始化；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，
会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用
要么是已经有实例了，要么是静态方法，都需要初始化；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的
类。

#### 不会初始化（可能会加载）
1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
2. 定义对象数组，不会触发该类的初始化。
3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不
会触发定义常量所在的类。
4. 通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始
化。
5. 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触
发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName
（“jvm.Hello”）默认会加载 Hello 类。
6. 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是
不初始化）。

#### 栈帧
栈帧是一个逻辑上的概念，具体的大小在
一个方法编写完成后基本上就能确定。

栈帧包括：返回值，局部变量表，操作数栈及 class 指针（标识这个栈帧对应的是哪个类的方法，指向非堆里面的 Class 对象）。

#### 堆与栈
对象、对象成员与类定义、静态变量以及数组都在堆上。

局部变量和对象引用地址在栈上。



#### 运行模式
1. -server：设置 JVM 使用 server 模式，特点是启动速度比较慢，但运行时性能和内存管理效率
很高，适用于生产环境。在具有 64 位能力的 JDK 环境下将默认启用该模式，而忽略 -client 参
数。
2. -client ：JDK1.7 之前在32位的 x86 机器上的默认值是 -client 选项。设置 JVM 使用 client 模
式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或
者 PC 应用开发和调试。此外，我们知道 JVM 加载字节码后，可以解释执行，也可以编译成本
地代码再执行，所以可以配置 JVM 对字节码的处理模式。
3. -Xint：在解释模式（interpreted mode）下运行，-Xint 标记会强制 JVM 解释执行所有的字节
码，这当然会降低运行速度，通常低10倍或更多。
4. -Xcomp：编译模式，-Xcomp 参数与-Xint 正好相反，JVM 在第一次使用时会把所有的字节码编译成本地
代码，从而带来最大程度的优化。【注意预热】
5. -Xmixed：-Xmixed 是混合模式，将解释模式和编译模式进行混合使用，由 JVM 自己决定，这
是 JVM 的默认模式，也是推荐模式。 我们使用 java -version 可以看到 mixed mode 等信息。


#### 堆内存相关参数：
1. -Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为4g。
这个内存不包括栈内存，也不包括堆外使用的内存。
2. -Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小，并
不是操作系统实际分配的初始值，而是GC先规划好，用到才分配。 专用服务
器上需要保持 –Xms 和 –Xmx 一致，否则应用刚启动可能就有好几个 FullGC。
当两者配置不一致时，堆内存扩容可能会导致性能抖动。
3. -Xmn, 等价于 -XX:NewSize，使用 G1 垃圾收集器 不应该 设置该选项，在其
他的某些业务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.
4. -XX：MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的
Meta空间无限大，此参数无效。
5. -XX：MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设
置该选项。
6. -XX：MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参
数跟 -Dsun.nio.MaxDirectMemorySize 效果相同。
7. -Xss, 设置每个线程栈的字节数。 例如 -Xss1m 指定线程栈为 1MB，与XX:ThreadStackSize=1m 等价